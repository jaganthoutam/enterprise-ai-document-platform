const AWS = require('aws-sdk');
const { v4: uuidv4 /**
 * Upload document to S3
 * @param {Object} event - Lambda event
 * @param {string} tableName - DynamoDB table name
 * @param {string} bucketName - S3 bucket name
 * @param {string} userId - User ID
 * @returns {Object} - Response with upload URL and document metadata
 */
async function uploadDocument(event, tableName, bucketName, userId) {
  // This would typically parse multipart form data, but for API Gateway,
  // we'll generate a presigned URL for direct upload instead
  
  // Extract file information from request
  const requestBody = JSON.parse(event.body || '{}');
  const fileName = requestBody.fileName;
  const fileType = requestBody.fileType;
  const fileSize = requestBody.fileSize;
  
  if (!fileName || !fileType) {
    return formatResponse(400, { message: 'fileName and fileType are required' });
  }
  
  // Generate a unique file key
  const timestamp = new Date().toISOString();
  const fileKey = `uploads/${userId}/${timestamp}-${fileName.replace(/[^a-zA-Z0-9._-]/g, '_')}`;
  const documentId = uuidv4();
  
  // Generate a presigned URL for uploading
  const s3Params = {
    Bucket: bucketName,
    Key: fileKey,
    ContentType: fileType,
    Expires: 3600, // URL expires in 1 hour
  };
  
  const uploadUrl = await s3.getSignedUrlPromise('putObject', s3Params);
  
  // Create document metadata
  const document = {
    PK: `DOC#${documentId}`,
    SK: 'METADATA',
    GSI1PK: userId,
    GSI1SK: timestamp,
    id: documentId,
    userId,
    title: fileName,
    description: requestBody.description || '',
    docType: requestBody.docType || getDocTypeFromFileType(fileType),
    tags: requestBody.tags || [],
    status: 'pending',
    createdAt: timestamp,
    updatedAt: timestamp,
    s3Key: fileKey,
    fileType: fileType,
    fileSize: fileSize || 0,
    access: requestBody.access || 'private',
    version: 1,
  };
  
  // Save document metadata to DynamoDB
  const params = {
    TableName: tableName,
    Item: document,
  };
  
  await dynamoDb.put(params).promise();
  
  // Publish event to EventBridge
  await publishDocumentEvent('DocumentUploadInitiated', {
    documentId,
    userId,
    timestamp,
    fileKey,
    fileType,
  });
  
  return formatResponse(200, {
    uploadUrl,
    document: formatDocumentResponse(document),
  });
}

/**
 * Publish document event to EventBridge
 * @param {string} eventType - Event type
 * @param {Object} detail - Event details
 * @returns {Promise} - EventBridge putEvents promise
 */
async function publishDocumentEvent(eventType, detail) {
  const params = {
    Entries: [
      {
        Source: 'com.myapp.documents',
        DetailType: eventType,
        Detail: JSON.stringify(detail),
        EventBusName: 'default',
      },
    ],
  };
  
  return eventBridge.putEvents(params).promise();
}

/**
 * Format document response to exclude internal fields
 * @param {Object} document - Document data from DynamoDB
 * @returns {Object} - Formatted document for response
 */
function formatDocumentResponse(document) {
  // Return only the fields that should be exposed to clients
  return {
    id: document.id,
    title: document.title,
    description: document.description,
    docType: document.docType,
    tags: document.tags,
    status: document.status,
    createdAt: document.createdAt,
    updatedAt: document.updatedAt,
    fileType: document.fileType,
    fileSize: document.fileSize,
    access: document.access,
    downloadUrl: document.downloadUrl,
    version: document.version,
  };
}

/**
 * Determine document type from file type
 * @param {string} fileType - MIME type of the file
 * @returns {string} - Document type
 */
function getDocTypeFromFileType(fileType) {
  if (fileType.startsWith('image/')) {
    return 'image';
  } else if (fileType.startsWith('video/')) {
    return 'video';
  } else if (fileType.startsWith('audio/')) {
    return 'audio';
  } else if (fileType === 'application/pdf') {
    return 'pdf';
  } else if (fileType.includes('spreadsheet') || fileType.includes('excel') || fileType.includes('csv')) {
    return 'spreadsheet';
  } else if (fileType.includes('presentation') || fileType.includes('powerpoint')) {
    return 'presentation';
  } else if (fileType.includes('document') || fileType.includes('word') || fileType.includes('text')) {
    return 'document';
  } else {
    return 'other';
  }
}

/**
 * Format error response
 * @param {Error} error - Error object
 * @returns {Object} - Formatted error response
 */
function formatError(error) {
  console.error('Error:', error);
  
  // Handle specific error types
  if (error.code === 'ConditionalCheckFailedException') {
    return formatResponse(409, {
      message: 'The document has been modified by another request. Please try again.',
    });
  } else if (error.code === 'ValidationException') {
    return formatResponse(400, {
      message: 'Invalid request data',
      error: error.message,
    });
  } else if (error.code === 'AccessDeniedException') {
    return formatResponse(403, {
      message: 'Access denied',
      error: error.message,
    });
  } else if (error.code === 'ResourceNotFoundException') {
    return formatResponse(404, {
      message: 'Resource not found',
      error: error.message,
    });
  }
  
  // Generic server error
  return formatResponse(500, {
    message: 'Internal server error',
    error: error.message,
  });
}

/**
 * Format response with status code and body
 * @param {number} statusCode - HTTP status code
 * @param {Object} body - Response body
 * @returns {Object} - Formatted response
 */
function formatResponse(statusCode, body) {
  return {
    statusCode,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*', // Update for production
      'Access-Control-Allow-Credentials': true,
    },
    body: JSON.stringify(body),
  };
}

// JSON schema for validation
const inputSchema = {
  type: 'object',
  properties: {
    body: {
      type: 'object',
      properties: {
        title: { type: 'string', minLength: 1, maxLength: 255 },
        description: { type: 'string', maxLength: 2000 },
        docType: { type: 'string' },
        tags: { 
          type: 'array',
          items: { type: 'string', maxLength: 50 },
          maxItems: 10
        },
        status: { 
          type: 'string',
          enum: ['draft', 'pending', 'active', 'archived']
        },
        access: {
          type: 'string',
          enum: ['private', 'shared', 'public']
        },
        fileName: { type: 'string' },
        fileType: { type: 'string' },
        fileSize: { type: 'number' },
      },
    },
  },
};

// Use middleware to enhance Lambda handler
const handler = middy(documentHandler)
  .use(jsonBodyParser()) // Parse JSON body
  .use(validator({ eventSchema: transpileSchema(inputSchema) })) // Validate input
  .use(httpErrorHandler()); // Handle errors

module.exports = { handler };
 = require('uuid');
const middy = require('@middy/core');
const jsonBodyParser = require('@middy/http-json-body-parser');
const httpErrorHandler = require('@middy/http-error-handler');
const validator = require('@middy/validator');
const { transpileSchema } = require('@middy/validator/transpile');

// Initialize AWS services
const s3 = new AWS.S3();
const dynamoDb = new AWS.DynamoDB.DocumentClient();
const eventBridge = new AWS.EventBridge();

/**
 * Document management Lambda function handler
 */
const documentHandler = async (event) => {
  console.log('Documents Lambda invoked with event:', JSON.stringify(event));
  
  try {
    // Get path parameters and HTTP method
    const httpMethod = event.httpMethod;
    const path = event.path;
    const pathParams = event.pathParameters || {};
    const queryParams = event.queryStringParameters || {};
    const documentId = pathParams.documentId;
    const userId = event.requestContext.authorizer.claims.sub;
    
    // Get environment variables
    const bucketName = process.env.DOCUMENT_BUCKET;
    const tableName = process.env.DYNAMODB_TABLE;
    
    // Route the request based on the method and path
    if (httpMethod === 'GET' && !documentId) {
      // List documents
      return await listDocuments(tableName, userId, queryParams);
    } else if (httpMethod === 'GET' && documentId) {
      // Get document by ID
      return await getDocument(tableName, bucketName, userId, documentId);
    } else if (httpMethod === 'POST' && path.includes('/upload')) {
      // Upload document
      return await uploadDocument(event, tableName, bucketName, userId);
    } else if (httpMethod === 'POST' && !documentId) {
      // Create document metadata
      return await createDocument(event.body, tableName, userId);
    } else if (httpMethod === 'PUT' && documentId) {
      // Update document
      return await updateDocument(event.body, tableName, userId, documentId);
    } else if (httpMethod === 'DELETE' && documentId) {
      // Delete document
      return await deleteDocument(tableName, bucketName, userId, documentId);
    } else {
      return formatResponse(400, { message: 'Invalid request method or path' });
    }
  } catch (error) {
    console.error('Error processing document request:', error);
    return formatError(error);
  }
};

/**
 * List documents for a user
 * @param {string} tableName - DynamoDB table name
 * @param {string} userId - User ID
 * @param {Object} queryParams - Query parameters
 * @returns {Object} - Response with documents list
 */
async function listDocuments(tableName, userId, queryParams) {
  // Parse pagination parameters
  const limit = parseInt(queryParams.limit) || 20;
  const startKey = queryParams.nextToken ? JSON.parse(Buffer.from(queryParams.nextToken, 'base64').toString()) : null;
  
  // Parse filter parameters
  const filters = [];
  let filterExpression = '';
  const expressionAttributeValues = {
    ':userId': userId,
  };
  
  // Always filter by user ID
  filters.push('userId = :userId');
  
  // Add type filter if provided
  if (queryParams.type) {
    filters.push('docType = :docType');
    expressionAttributeValues[':docType'] = queryParams.type;
  }
  
  // Add status filter if provided
  if (queryParams.status) {
    filters.push('#status = :status');
    expressionAttributeValues[':status'] = queryParams.status;
  }
  
  // Add date range filter if provided
  if (queryParams.startDate && queryParams.endDate) {
    filters.push('createdAt BETWEEN :startDate AND :endDate');
    expressionAttributeValues[':startDate'] = queryParams.startDate;
    expressionAttributeValues[':endDate'] = queryParams.endDate;
  }
  
  // Build filter expression
  if (filters.length > 0) {
    filterExpression = filters.join(' AND ');
  }
  
  // Prepare query parameters
  const params = {
    TableName: tableName,
    IndexName: 'GSI1',
    KeyConditionExpression: 'GSI1PK = :userId',
    ExpressionAttributeValues: expressionAttributeValues,
    Limit: limit,
  };
  
  // Add filter expression if exists
  if (filterExpression) {
    params.FilterExpression = filterExpression;
    
    // Add expression attribute names for reserved keywords
    if (queryParams.status) {
      params.ExpressionAttributeNames = {
        '#status': 'status',
      };
    }
  }
  
  // Add pagination token if exists
  if (startKey) {
    params.ExclusiveStartKey = startKey;
  }
  
  // Query DynamoDB
  const result = await dynamoDb.query(params).promise();
  
  // Format response
  const response = {
    documents: result.Items.map(formatDocumentResponse),
    count: result.Count,
    scannedCount: result.ScannedCount,
  };
  
  // Add pagination token if more results exist
  if (result.LastEvaluatedKey) {
    response.nextToken = Buffer.from(JSON.stringify(result.LastEvaluatedKey)).toString('base64');
  }
  
  return formatResponse(200, response);
}

/**
 * Get document by ID
 * @param {string} tableName - DynamoDB table name
 * @param {string} bucketName - S3 bucket name
 * @param {string} userId - User ID
 * @param {string} documentId - Document ID
 * @returns {Object} - Response with document data
 */
async function getDocument(tableName, bucketName, userId, documentId) {
  // Get document metadata from DynamoDB
  const metadataParams = {
    TableName: tableName,
    Key: {
      PK: `DOC#${documentId}`,
      SK: 'METADATA',
    },
  };
  
  const metadataResult = await dynamoDb.get(metadataParams).promise();
  const documentData = metadataResult.Item;
  
  // Check if document exists
  if (!documentData) {
    return formatResponse(404, { message: 'Document not found' });
  }
  
  // Check if user has access to the document
  if (documentData.userId !== userId && documentData.access !== 'public') {
    return formatResponse(403, { message: 'You do not have permission to access this document' });
  }
  
  // If document is stored in S3, generate presigned URL
  if (documentData.s3Key) {
    const s3Params = {
      Bucket: bucketName,
      Key: documentData.s3Key,
      Expires: 3600, // URL expires in 1 hour
    };
    
    try {
      const url = await s3.getSignedUrlPromise('getObject', s3Params);
      documentData.downloadUrl = url;
    } catch (error) {
      console.error('Error generating S3 presigned URL:', error);
      documentData.downloadUrl = null;
    }
  }
  
  return formatResponse(200, formatDocumentResponse(documentData));
}

/**
 * Create document metadata
 * @param {Object} documentData - Document data
 * @param {string} tableName - DynamoDB table name
 * @param {string} userId - User ID
 * @returns {Object} - Response with created document
 */
async function createDocument(documentData, tableName, userId) {
  // Generate document ID
  const documentId = uuidv4();
  const timestamp = new Date().toISOString();
  
  // Create document item
  const document = {
    PK: `DOC#${documentId}`,
    SK: 'METADATA',
    GSI1PK: userId,
    GSI1SK: timestamp,
    id: documentId,
    userId,
    title: documentData.title,
    description: documentData.description || '',
    docType: documentData.docType || 'other',
    tags: documentData.tags || [],
    status: documentData.status || 'draft',
    createdAt: timestamp,
    updatedAt: timestamp,
    s3Key: documentData.s3Key || null,
    fileType: documentData.fileType || null,
    fileSize: documentData.fileSize || 0,
    access: documentData.access || 'private',
    version: 1,
  };
  
  // Save document to DynamoDB
  const params = {
    TableName: tableName,
    Item: document,
  };
  
  await dynamoDb.put(params).promise();
  
  // Publish event to EventBridge
  await publishDocumentEvent('DocumentCreated', {
    documentId,
    userId,
    timestamp,
    documentType: document.docType,
  });
  
  return formatResponse(201, formatDocumentResponse(document));
}

/**
 * Update document
 * @param {Object} documentData - Document data
 * @param {string} tableName - DynamoDB table name
 * @param {string} userId - User ID
 * @param {string} documentId - Document ID
 * @returns {Object} - Response with updated document
 */
async function updateDocument(documentData, tableName, userId, documentId) {
  // Get existing document
  const getParams = {
    TableName: tableName,
    Key: {
      PK: `DOC#${documentId}`,
      SK: 'METADATA',
    },
  };
  
  const result = await dynamoDb.get(getParams).promise();
  const existingDocument = result.Item;
  
  // Check if document exists
  if (!existingDocument) {
    return formatResponse(404, { message: 'Document not found' });
  }
  
  // Check if user has permission to update the document
  if (existingDocument.userId !== userId) {
    return formatResponse(403, { message: 'You do not have permission to update this document' });
  }
  
  const timestamp = new Date().toISOString();
  
  // Prepare update expression
  let updateExpression = 'SET updatedAt = :updatedAt, version = :newVersion';
  const expressionAttributeValues = {
    ':updatedAt': timestamp,
    ':newVersion': existingDocument.version + 1,
    ':currentVersion': existingDocument.version,
  };
  
  // Add fields to update expression
  if (documentData.title) {
    updateExpression += ', title = :title';
    expressionAttributeValues[':title'] = documentData.title;
  }
  
  if (documentData.description !== undefined) {
    updateExpression += ', description = :description';
    expressionAttributeValues[':description'] = documentData.description;
  }
  
  if (documentData.docType) {
    updateExpression += ', docType = :docType';
    expressionAttributeValues[':docType'] = documentData.docType;
  }
  
  if (documentData.tags) {
    updateExpression += ', tags = :tags';
    expressionAttributeValues[':tags'] = documentData.tags;
  }
  
  if (documentData.status) {
    updateExpression += ', #status = :status';
    expressionAttributeValues[':status'] = documentData.status;
  }
  
  if (documentData.access) {
    updateExpression += ', access = :access';
    expressionAttributeValues[':access'] = documentData.access;
  }
  
  // Update document in DynamoDB
  const updateParams = {
    TableName: tableName,
    Key: {
      PK: `DOC#${documentId}`,
      SK: 'METADATA',
    },
    UpdateExpression: updateExpression,
    ExpressionAttributeValues: expressionAttributeValues,
    ConditionExpression: 'version = :currentVersion',
    ReturnValues: 'ALL_NEW',
  };
  
  // Add expression attribute names for reserved keywords
  if (documentData.status) {
    updateParams.ExpressionAttributeNames = {
      '#status': 'status',
    };
  }
  
  try {
    const updateResult = await dynamoDb.update(updateParams).promise();
    const updatedDocument = updateResult.Attributes;
    
    // Publish event to EventBridge
    await publishDocumentEvent('DocumentUpdated', {
      documentId,
      userId,
      timestamp,
      documentType: updatedDocument.docType,
      status: updatedDocument.status,
    });
    
    return formatResponse(200, formatDocumentResponse(updatedDocument));
  } catch (error) {
    if (error.code === 'ConditionalCheckFailedException') {
      return formatResponse(409, {
        message: 'The document has been modified by another request. Please try again.',
      });
    }
    throw error;
  }
}

/**
 * Delete document
 * @param {string} tableName - DynamoDB table name
 * @param {string} bucketName - S3 bucket name
 * @param {string} userId - User ID
 * @param {string} documentId - Document ID
 * @returns {Object} - Response
 */
async function deleteDocument(tableName, bucketName, userId, documentId) {
  // Get existing document
  const getParams = {
    TableName: tableName,
    Key: {
      PK: `DOC#${documentId}`,
      SK: 'METADATA',
    },
  };
  
  const result = await dynamoDb.get(getParams).promise();
  const document = result.Item;
  
  // Check if document exists
  if (!document) {
    return formatResponse(404, { message: 'Document not found' });
  }
  
  // Check if user has permission to delete the document
  if (document.userId !== userId) {
    return formatResponse(403, { message: 'You do not have permission to delete this document' });
  }
  
  // Delete the document from S3 if it exists
  if (document.s3Key) {
    const s3Params = {
      Bucket: bucketName,
      Key: document.s3Key,
    };
    
    await s3.deleteObject(s3Params).promise();
  }
  
  // Delete document from DynamoDB
  const deleteParams = {
    TableName: tableName,
    Key: {
      PK: `DOC#${documentId}`,
      SK: 'METADATA',
    },
  };
  
  await dynamoDb.delete(deleteParams).promise();
  
  // Publish event to EventBridge
  await publishDocumentEvent('DocumentDeleted', {
    documentId,
    userId,
    timestamp: new Date().toISOString(),
  });
  
  return formatResponse(200, { message: 'Document deleted successfully' });
}